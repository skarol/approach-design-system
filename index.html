<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Approaching Design System in iOS Environment</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/skarol-dark.css">
		<link rel="stylesheet" href="styles.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/atom-one-dark.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-timing="20">
					<h2 class="gradient-text">
						<p>Approaching Design System</p>
						<p>in iOS Environment</p>
					</h2>
					<aside class="notes" data-markdown>
						Hello everyone.
						
						Today I will talk about approaching Design System 
						
						and making this experience as delightfully as possible.
					</aside>
				</section>
				<section class="contact" data-timing="90">
					<div class="contact-header">	
						<h3 class="gradient-text">Karolina Samorek</h3>
						<h5>Senior iOS Developer 
							<a href="https://www.lakecoloring.com" target="_blank" rel="noreferrer">
								@lakecoloring
								<img class="app-icon" src="./assets/icons/Icon-1024.png" alt="icon"/>
							</a>
						</h5>
					</div>
					<ul class="contact-links" style="list-style:none">
						<li>
						  <div class="contact-link">
							<a href="https://bit.ly/3dQx4pB" target="_blank" rel="noreferrer">
							  <img class="icon" src="./assets/icons/github.svg" alt="icon"/>@skarol
							</a>
						  </div>
						</li>
						<li>
						  <div class="contact-link">
							<a href="https://bit.ly/3dPg70m" target="_blank" rel="noreferrer">
							  <img class="icon" src="./assets/icons/twitter.svg" alt="icon"/>@skarol_the
							</a>
						  </div>
						</li>
						<!-- <li>
						  <div class="contact-link">
							<a href="mailto:karolina.samorek@gmail.com" target="_blank" rel="noreferrer">
							  <img class="icon" src="/assets/icons/mail.svg" alt="icon"/>
							  karolina.samorek@gmail.com
							</a>
						  </div>
						</li> -->
						<li>
							<div class="contact-link">
							  <a href="https://bit.ly/3dR28Wl" target="_blank" rel="noreferrer">
								<img class="icon" src="./assets/icons/linkedin.svg" alt="icon"/>@karolina.samorek
							  </a>
							</div>
						  </li>
					  </ul>
					<aside class="notes" data-markdown>
						My name is Karolina Samorek
						and I'm a Senior iOS Developer at Lake.

						<!-- At Lake we build user experience with beautiful design. -->
						
						Since I started iOS development, every time I was working on UI, 
						I had mixed feelings.
						
						From one side I really like to work on beautiful things. 
						Being able to interact with something I developed. 

						However it wasn't always like that. 
						I struggled with creating same things over and over again. 
						With edge cases, like different screen sizes or waiting long to see results due to compilation time.

						So, during this talk I'm will show you what works for me 
						to limit those frustrations
						and embrace building UI.

						‚úã‚úã‚úãüö∞
					</aside>
				</section>
<!-- DEVELOPMENT PERFORMANCE -->
				<section data-markdown>
					<script type="text/template">
						## Shorten the waiting time <!-- .element: class="gradient-text" -->
						* hot reloading
						* Xcode previews
						* modulated codebase
						
						Note:
						First thing you can do to make your experience with UI more present,
						is shorten the waiting time.

						Yesterday Krzysztof had a great talk about it. 
						
						Hot reloading magic and so on.
						
						However I do have a comment on one thing. 
						For me Xcode previews (if they work) are great. I can see a result on multiple devices at once.
						But in order to make them work you have to have modularized codebase and build just a small portion of it
						every time you change something.

						‚úã‚úã‚úãüö∞
					</script>
				</section>
<!-- EDGE CASES - SIZE VARIANTS -->
				<section data-auto-animate>
					<h2 class="gradient-text">Handle edge cases</h2>
					<img class="iphone-ipad-image" src="./assets/small_large.png" alt="iPhone SE 1st gen vs iPad Pro 12.9 size comparition"/>
					<aside class="notes" data-markdown>
						If it comes to edge cases. 

						Many of them are just related to trying to build UI for variety of screen sizes. 
						
						Sometimes it's just not physically possible to fit same content in all of them.
						Like for example on the smallest iPhone and the biggest iPad.
						
						Another time, to look more friendly for the user, the content has to be constructed differently depending on the screen size. 
						
						Each of this exception is basically an if in the code. 
					</aside>
				</section>
				<section data-auto-animate>
					<h2>Handle edge cases</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="|1|3-6|8-12|14-17">
							<script type="text/template">
							let screenInsets = SizeVariants<CGFloat>(small: 12, compact: 16, regular: 24)

							let bannerRatio = SizeVariants<CGFloat>(
								compact: 180.0 / 348.0, 
								regular: 200.0 / 500.0
							)

							let header1 = SizeVariants<DSFont>(
								compact: headers.withSize(32),
								regular: headers.withSize(48)
							)
							private let headers = DSFont.systemFont(ofSize: 22, weight: .bold)

							let image = SizeVariants<DSImage>(
								compact: DSImage(named: "background.compact"),
								regular: DSImage(named: "background.regular")
							)
							</script>
							</code>
					</pre>
					<aside class="notes" data-markdown>
						To simplify things at Lake we created `SizeVariants`. 
						
						You can thing about them as an extended size classes that let you declare rules for each screen size.

						Instead of making exceptions we describe the behavior for each variant.
						
						We use this type to define things such us,
						
						* ‚è≠ insets,
						* ‚è≠ ratio of UI elements, 
						* ‚è≠ fonts 
						* ‚è≠ or even different image assets.
					</aside>
				</section>
				<section data-auto-animate>
					<h2>Handle edge cases</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="3-12|9-10|11-12|7-8|5-6|3-4|26-38">
							<script type="text/template">
							/// Defines a way layout is constructed for different screen sizes.
							public struct SizeVariants<Variant> {
								/// The Variant for iPhones 4".
								public var small: Variant
								/// The Variant for iPhone 4.7".
								public var short: Variant
								/// The Variant for the iPhones wider than iPhone 4.7".
								public var compact: Variant
								/// The Variant for all iPads in portrait orientation.
								public var regular: Variant
								/// The Variant for all iPads in landscape orientation.
								public var wide: Variant

								/// Create SizeVariants.
								/// - Parameters:
								///   - small: The Variant for iPhones 4". 
								///     If not provided `short` is used.
								///   - short: The Variant for iPhone 4.7".
								///     If not provided `compact` is used.
								///   - compact: The Variant for the iPhones wider than iPhone 4.7". 
								///     If not provided `regular` is used.
								///   - regular: The Variant for all iPads in portrait. 
								///     Used as a final fallback for each variant if not provided.
								///   - wide: The Variant for all iPads in landscape. 
								///     If not provided `regular` is used.
								public init(
									small: Variant? = nil, 
									short: Variant? = nil, 
									compact: Variant? = nil, 
									regular: Variant, 
									wide: Variant? = nil
								) {
									self.small = small ?? short ?? compact ?? regular
									self.short = short ?? compact ?? regular
									self.compact = compact ?? regular
									self.regular = regular
									self.wide = wide ?? regular
								}
							}
						</script>
						</code>
					</pre>
					<aside class="notes" data-markdown>
						If you take a look on `SizeVariants` is's a simple, generic struct.
						
						It should define variants in a way that fits to the product you are building.
						
						For example, Lake is iPad-first,
						
						‚è≠ and we use regular as our default variant. It handles all iPads in portrait orientation (excluding split view).
						
						‚è≠ In our case it's common that iPads in landscape orientation have their dedicated layout,
						so we have a variant called wide.
						
						‚è≠ Compact is basically iPhone in Portrait (as we don't support landscape for iPhone in our app).
						To handle edge cases for smaller iPhones we introduced two more types
						
						‚è≠ short which takes care of iPhones with screen smaller than 4.7 inches.

						‚è≠ And small for the smallest iPhones with 4 inches screen size.
						
						‚è≠ You can see that variant, if not defined, fallbacks to larger one.
						
						And at the end to regular, which has to be always provided.

						‚úã‚úã‚úãüö∞
					</aside>
				</section>
<!-- DEFINING DESIGN SYSTEM -->
				<section data-auto-animate data-markdown>
					<script type="text/template">
						### Eliminate repetitive work <!-- .element: class="gradient-text" -->
						
						Notes:
						Next topic on my list of UI frustrations is repetitive work.
						The best way I know to eliminate it
					</script>
				</section>
				<section data-auto-animate data-markdown>
					<script type="text/template">
						### Eliminate repetitive work <!-- .element: class="gradient-text" -->
						#### by
						#### adopting
						
						Notes:
						is to adopt
					</script>
				</section>
				<section data-auto-animate data-markdown>
					<script type="text/template">
						### Eliminate repetitive work <!-- .element: class="gradient-text" -->
						#### by
						#### adopting
						## The Design System <!-- .element: class="gradient-text" -->
						
						Notes:
						the Design System.
						
						Simply create a framework that will let you build UI from reusable components

						‚úã
					</script>
				</section>
				<section data-auto-animate data-markdown>
					<script type="text/template">
						## The Design System <!-- .element: class="gradient-text" -->
						
						Notes:
						There are many ways you can approach it, 

						however there is one significant thing I've learned over the years.
						
						The Design System, is a product itself, just like apps we work on.

						And this product should be designed
						
						having best interest of it's users
						
						in mind.
					</script>
				</section>
				<section data-auto-animate data-markdown>
					<script type="text/template">
						## The Design System <!-- .element: class="gradient-text" -->
						* Designers
						* UX Researchers
						* Product Owners
						* Developers

						Notes:
						And by Users I mean 
						* ofc Designers and UX Researchers
						* but also Product Owners
						* and us, Developers

						To get maximum out of The Design System
						each of those groups has to be involved in the process of creating it.

						‚úã‚úã‚úã
					</script>
				</section>
				<section>
					<h2>Tokens</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="2-13|16-20, 24-25, 27-28">
							/// All DesignSystem Tokens namespace.
							public enum DSTokens {
								/// All DesignSystem Fonts namespace.
								public enum Fonts {}
								/// All DesignSystem Colors namespace.
								public enum Colors {}
								/// All DesignSystem Icons namespace.
								public enum Icons {}
								/// All DesignSystem Spaces namespace.
								public enum Spaces {}
								
								// ..
							}

							extension DSTokens.Colors {
								/// Background/Primary color
								public static let backgroundPrimary = DSColor(
									light: CGColor.from(hex: "#F5F5F5")!,
									dark: CGColor.from(hex: "#222222")!
								)
								
								// ...
								
								/// Text/OnColor color
								public static let textOnColor = DSColor(CGColor.from(hex: "#FAFAFA")!)

								/// Accent/Primary/Default
								public static let accentPrimaryDefault = DSColor(CGColor.from(hex: "#AA49D8")!)
								
								// ...
							}

						</code>
					</pre>
					
					<aside class="notes" data-markdown>
						You can start from defining tokens, which are parameters we will later use to style components.
						
						Like Fonts, Colors, Icons, Spaces etc.

						If you already support `UIKit` and `SwiftUI`, or you are thinking about transitioning into `SwiftUI`
						define your tokens in a way you will be able to use them with both frameworks.

						You might use `UIKit` types and convert them to `SwiftUI` ones, or the opposite. 
						You could also create your own types.
						
						‚è≠ Like here, where we have our own type `Design System Color` which uses `CGColor` from `CoreGraphics` library.
						So this type is independent from `UIKit`, but can be easily used with it
						as well as with `SwiftUI`.
						
						‚úã
					</aside>
				</section>
				<section>
					<h2>Control states</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="|5-7|8-10|11-13">
							/// State of UI control.
							///
							/// Possible options: ``normal``, ``highlighted`` and ``disabled``.
							public struct ControlState: OptionSet, Hashable {
								/// Normal UI control's state.
								/// Applicable when no user action is being performed and control is enabled.
								public static let normal = ControlState(rawValue: 1)
								/// Highlighted UI control's state.
								/// Applicable when user taps/presses and control is enabled.
								public static let highlighted = ControlState(rawValue: 2)
								/// Disabled UI control's state.
								/// Applicable when control isn't enabled.
								public static let disabled = ControlState(rawValue: 4)

								// ...
							}
						</code>
					</pre>
					<aside class="notes" data-markdown>
						Then think about all possible states you want your controls to have.

						* ‚è≠ For example the normal state, when no user action is being performed.
						* ‚è≠ highlighted, when user taps the control
						* ‚è≠ and disabled, when no user interaction is possible.

						‚úã
					</aside>
				</section>
				<section data-markdown data-auto-animate>
					<script type="text/template">
						## Style Components <!-- .element: class="gradient-text" -->

						Note:
						By combining `Tokens`, `ControlStates` and `SizeVariants` together 
						
						you can define styles of your components. 
					</script>
				</section>
				<section data-auto-animate>
					<h2>Style Components</h2>
					<div style="margin-left: 1rem;">
						<img src="./assets/button-animation.gif" />
					</div>
					<aside class="notes" data-markdown>
						Let's follow an example of styling Call To Action Button like this one.

						It has some font, corner radius and background color that changes with a tap.
					</aside>
				</section>
				<section data-auto-animate>
					<div style="margin-left: 1rem;">
						<img src="./assets/button-animation.gif" />
					</div>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="2-4|8-9|15-26|27-36">
							<script type="text/template">
							extension DSTokens.Fonts {	
								static let button = SizeVariants<DSFont>(
									regular: DSFont.systemFont(ofSize: 17, weight: .medium)
								)
							}

							extension DSStyles.Texts {
								public static let button = DSTokens.Fonts.button
									.toTextAttributes(color: DSTokens.Colors.textOnColor)
							}

							extension DSStyles.Buttons {
								public static let ctaPrimary = DSStyles.Texts.button
									.toButtonAttributes(
										stateViewAttributes: SizeVariants(
											regular: [
												.normal: .init(
													backgroundColor: DSTokens.Colors.accentPrimaryDefault,
													cornerRadius: DSTokens.CornerRadiuses.s
												),
												.highlighted: .init(
													backgroundColor: DSTokens.Colors.accentPrimaryHighlighted,
													cornerRadius: DSTokens.CornerRadiuses.s
												)
											]
										),
										contentInsets: SizeVariants<LayoutEdgeInsets>(
											compact: [
												.horizontal: DSTokens.Spaces.s, 
												.vertical: DSTokens.Spaces.xs
											],
											regular: [
												.horizontal: DSTokens.Spaces.m, 
												.vertical: DSTokens.Spaces.s
											]
										)
									)
							}
						</script>
						</code>
					</pre>
					<aside class="notes" data-markdown>
						* first we define font for a button, as a SizeVariant of DSFont, which is the same for each screen size, because we only provide regular Size Variant
						* ‚è≠ later we use it by calling a helper method and converting into `ViewAttributes` with specific text color
						* ‚è≠ and then we convert text style we just defined to a `ButtonAttributes` by applying attributes for normal and highlighted control states, such us background color and corner radius
						* ‚è≠ and different content insets for iphones and ipads.

						‚úã
					</aside>
				</section>
<!-- Attributes -->
				<section>
					<h2>Components Attributes</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers>
							/// UI Attributes that can be applied on a view to change it visually.
							public struct ViewAttributes: Equatable, Hashable {
								/// View's Background Color. Wont't be set if ``nil``.
								public var backgroundColor: DSColor?
								/// View's Tint Color. Wont't be set if ``nil``.
								public var tintColor: DSColor?
								/// Attributes applied to view's border. Wont't be set if ``nil``.
								public var borderAttributes: BorderAttributes?
								/// View's corner radius. Wont't be set if ``nil``.
								public var cornerRadius: CGFloat?
								/// Attributes related to view's shadow. Wont't be set if ``nil``.
								public var shadowAttributes: ShadowAttributes?

								// ...
							}
						</code>
					</pre>
					<aside class="notes" data-markdown>
						For better understanding, let's take a look on example attributes that define style of a view component.
						Things like background color, corner radius, some border or shadow.
						How you define those properties depend on how the Design System looks.

						‚úã
					</aside>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Applying attributes to a Button
						```swift [|14-18|20,22|21|23]
						/// Design System Button Style.
						///
						/// Applies ``ButtonAttributes`` to a button.
						public struct DSButtonStyle: ButtonStyle {
							public let attributes: ButtonAttributes

							/// Creates a view that represents the body of a button.
							///
							/// The system calls this method for each ```Button``` instance in a view
							/// hierarchy where this style is the current button style.
							///
							/// - Parameter configuration : The properties of the button.
							public func makeBody(configuration: Configuration) -> some View {
								let currentState: ControlState = configuration.isPressed 
									? .highlighted 
									: .normal
								let currentStateAttributes = attributes.stateAttributes[currentState] 
									?? attributes.stateAttributes[.normal]
								configuration.label
									.apply(textAttributes: currentStateAttributes?.textAttributes)
									.padding(attributes.contentInsets)
									.apply(viewAttributes: currentStateAttributes?.viewAttributes)
									.animation(.default, value: configuration.isPressed)
							}
						}
						```
						Note:
						To apply attributes to a component create set of methods and types.
						
						Like for `Button` in `SwiftUI` where you can implement a struct conforming to `ButtonStyle`.

						* ‚è≠ You can see that attributes for current control stated
						* ‚è≠ are applied by delegating text and view attributes is separate methods,
						* ‚è≠ also padding is being added
						* ‚è≠ and changes of control state are animated
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Applying attributes to a UIView
						```swift [|12,15]
						/// Applies ViewAttributes for given UIView.
						/// - Parameter attributes: The View Attributes to apply on a view.
						public func apply(attributes: ViewAttributes) {
							if let backgroundColor = attributes.backgroundColor {
								self.backgroundColor = UIColor(dsColor: backgroundColor)
							}
							if let tintColor = attributes.tintColor {
								self.tintColor = UIColor(dsColor: tintColor)
							}
							layer.cornerRadius = attributes.cornerRadius ?? .zero
							if let shadowAttributes = attributes.shadowAttributes {
								apply(attributes: shadowAttributes)
							}
							if let borderAttributes = attributes.borderAttributes {
								apply(attributes: borderAttributes)
							}
						}
						```
						Note:
						In `UIKit` we can use same attributes, however we have to write separate functions applying styles.
						As our controls have different API.

						‚úã

						There are more methods like those. 
						
						Good thing is the attributes are composable so for example ViewAttributes contains ShadowAttributes and BorderAttributes.
						‚è≠ So you can compose functions applying those attributes as well.

						And you write them once to use them later on.
						
						However this is not what I want to dig into today.
						
						If you are interested there is an repository on my github, where you can find more details.

						Not all is pushed yet, but you can expect this soon.

						‚úã‚úã‚úãüö∞
					</script>
				</section>
<!-- DEMO -->				
				<section data-auto-animate>
					<h2 class="gradient-text">Feature level of Styles</h2>
					<aside class="notes" data-markdown>
						Before I've shown styling a Call To Action Button.
						The style was defined on the Design System level.
						
						However, we can also take advantage of them on a feature level.

						Imagine we have to create a banner for WWDC Community Event.
					</aside>
				</section>
				<section data-auto-animate>
					<h2 class="gradient-text">Feature level of Styles</h2>
					<img src="./assets/wwdc_banner_design.png" alt="example design" />
					<aside class="notes" data-markdown>
						It should look like this.
						
						Nothing super fancy, but it's slightly different on each device.

						It might be not visible on first look, but the ratio of the banner is different on iPhones and iPads 
						
						and the title font on iPhone SE is smaller.
						
						‚úã‚úã‚úãüö∞
					</aside>
				</section>
<!-- SwiftUI -->
				<section data-auto-animate>
					<h2>Feature level of Styles</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="|2-3|5-18">
							<script type="text/template">
							enum WWDCBannerStyle {
								static let container = DSStyles.Shadows.banner
									.toViewAttributes(cornerRadius: DSTokens.CornerRadiuses.l)
							
								static let header = DSStyles.Texts.header2onColor
								static let body = DSStyles.Texts.bodyOnColor
								static let button = DSStyles.Buttons.primaryCTA

								static let bannerRatio = SizeVariants<CGFloat>(
									compact: 230.0 / 348.0, 
									regular: 200.0 / 500.0
								)
								static let backgroundImage = DSStyles.Shadows.banner
									.toViewAttributes(cornerRadius: DSTokens.CornerRadiuses.l)
									.toImageAttributes(image: .init(
										compact: DSImage(named: "background.compact"),
										regular: DSImage(named: "background.regular")
									))
							}
							</script>
						</code>
					</pre>
					<aside class="notes" data-markdown>
						We can start from defining feature styles, by reusing the Design System.
						
						‚è≠ Like taking already defined shadow and converting it to `ViewAttributes` with specific corner radius.

						‚è≠ Similar approach we use to declare other styles. We basically take what Design System provides and build on top of that.
					</aside>
				</section>
				<section data-auto-animate>
					<div class="r-hstack">
						<img src="./assets/swiftUI/01.png" />
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="4-16|6-9">
								struct WWDCBannerView: View {
									@EnvironmentObject var layout: Layout
								
									var body: some View {
										Image(
											SizeVariants(
												compact: "background.compact",
												regular: "background.regular"
											).for(screen: layout.screen)
										)
										.resizable()
										.aspectRatio(contentMode: .fit)
										.frame(maxWidth: 500)
										.padding(DSTokens.Spaces.l)
									}
								}
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Having styles defined we can start building UI. 
						
						Here we have just a background of the banner.

						‚è≠  We already provide asset as a `SizeVariant`.
						
						You could now ask, why we don't take advantage of Xcode assets and instead of universal define iPhone and iPad separately.
						However split view would then look really bad.
					</aside>
				</section>
				<section data-auto-animate>
					<div class="r-hstack">
						<img src="./assets/swiftUI/02.png" />
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="12-14">
								struct WWDCBannerView: View {
									@EnvironmentObject var layout: Layout
								
									var body: some View {
										Image(
											SizeVariants(
												compact: "background.compact",
												regular: "background.regular"
											).for(screen: layout.screen)
										)
										.resizable()
										.apply(viewAttributes: WWDCBannerStyle.container.for(
											screen: layout.screen
										))
										.aspectRatio(contentMode: .fit)
										.frame(maxWidth: 500)
										.padding(DSTokens.Spaces.l)
									}
								}
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Buy simply adding one function call we restyle the background, to have rounded corners and shadow below.
					</aside>
				</section>
				<section data-auto-animate>
					<div class="r-hstack">
						<img src="./assets/swiftUI/02.png" />
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="20-31">
								struct WWDCBannerView: View {
									@EnvironmentObject var layout: Layout
								
									var body: some View {
										Image(
											SizeVariants(
												compact: "background.compact",
												regular: "background.regular"
											).for(screen: layout.screen)
										)
										.resizable()
										.apply(viewAttributes: WWDCBannerStyle.container.for(
											screen: layout.screen
										))
										.aspectRatio(contentMode: .fit)
										.frame(maxWidth: 500)
										.padding(DSTokens.Spaces.l)
									}

									@ViewBuilder private var foreground: some View {
										HStack {
											Spacer()
											VStack(alignment: .trailing, spacing: DSTokens.Spaces.s) {
												Text("WWDC22")
												Text("Community Event")
												Spacer()
												Button("Join Now") { /* ... */ }
											}
											.padding(DSTokens.Spaces.l)
										}
									}
								}
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Now let see what we can do with the foreground. 
						
						Simple `VStack` with `Texts`, `Button` and `Spacer` in between should work.

						Let's add it to our banner as an overlay.
					</aside>
				</section>
				<section data-auto-animate>
					<div class="r-hstack">
						<img src="./assets/swiftUI/03.png" />
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="16|21-32">
								struct WWDCBannerView: View {
									@EnvironmentObject var layout: Layout
								
									var body: some View {
										Image(
											SizeVariants(
												compact: "background.compact",
												regular: "background.regular"
											).for(screen: layout.screen)
										)
										.resizable()
										.apply(viewAttributes: WWDCBannerStyle.container.for(
											screen: layout.screen
										))
										.aspectRatio(contentMode: .fit)
										.overlay(foreground)
										.frame(maxWidth: 500)
										.padding(DSTokens.Spaces.l)
									}

									@ViewBuilder private var foreground: some View {
										HStack {
											Spacer()
											VStack(alignment: .trailing, spacing: DSTokens.Spaces.s) {
												Text("WWDC22")
												Text("Community Event")
												Spacer()
												Button("Join Now") { /* ... */ }
											}
											.padding(DSTokens.Spaces.l)
										}
									}
								}
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Well, we are going in the right direction. But we are not there yet.
						
						It doesn't look like on the design.

						‚è≠ Let's style components we just created.
					</aside>
				</section>
				<section data-auto-animate>
					<div class="r-hstack">
						<img src="./assets/swiftUI/04.png" />
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="26-28,30-32,35-37">
								struct WWDCBannerView: View {
									@EnvironmentObject var layout: Layout
								
									var body: some View {
										Image(
											SizeVariants(
												compact: "background.compact",
												regular: "background.regular"
											).for(screen: layout.screen)
										)
										.resizable()
										.apply(viewAttributes: WWDCBannerStyle.container.for(
											screen: layout.screen
										))
										.aspectRatio(contentMode: .fit)
										.overlay(foreground)
										.frame(maxWidth: 500)
										.padding(DSTokens.Spaces.l)
									}

									@ViewBuilder private var foreground: some View {
										HStack {
											Spacer()
											VStack(alignment: .trailing, spacing: DSTokens.Spaces.s) {
												Text("WWDC22")
													.apply(textAttributes: WWDCBannerStyle.header.for(
														screen: layout.screen
													))
												Text("Community Event")
													.apply(textAttributes: WWDCBannerStyle.body.for(
														screen: layout.screen
													))
												Spacer()
												Button("Join Now") { /* ... */ }
													.buttonStyle(DSButtonStyle(
														attributes: WWDCBannerStyle.button.for(screen: layout.screen)
													))
											}
											.padding(DSTokens.Spaces.l)
										}
									}
								}
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Agin, few lines of code and UI is transformed.

						The best thing is that it does all the magic for edge cases.

						Let me show you how it behaves.
					</aside>
				</section>
				<section data-auto-animate>
					<video class="demo-video" data-autoplay src="./assets/swiftUI/final.mov"></video>
					<aside class="notes" data-markdown>
						It looks good in
						* portrait
						* landscape
						* and even in split view.

						You can see, by a banner ratio, that it uses smaller size variants for split view.

						Building our example with `SwiftUI` was pretty straight forward. 
						But what with UIKit? Some of us still have to write UI with it.
						For those Design System has to support both frameworks.

						Let's see if we can adopt it by building same example with UIKit.
						But first we gonna add some types that will help us.
					</aside>
				</section>
<!-- UIKit -->
				<section data-auto-animate>
					<div class="r-hstack">
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="|3-5|11-18">
								<script type="text/template">
								/// Stores ``View`` and it's ``Attributes``.
								@propertyWrapper public class LayoutView<View: AttributedView> {
									public var wrappedValue: View
									public let attributes: SizeVariants<View.Attributes>
									public var projectedValue: LayoutView<View> { self }

									private var cancellables: Set<AnyCancellable> = []

									/// Observes ``Layout.screen`` and perform updatecs when it changes.
									/// - Parameter layout: Layout observable object, to observe.
									public func startObserving(layout: Layout) {
										wrappedValue.startUpdating(
											attributes: layout.$screen
												.map(attributes.for(screen:))
												.eraseToAnyPublisher(),
											store: &cancellables
										)
									}
								}
								</script>
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Again, this is just an example of how you can approach it.
						I wanted to make it as clear as possible and declare attributes close to the components.
						So I thought, if I still have to use UIKit, why not take advantage of property wrappers.

						Here it is.

						‚è≠ It stores view together with it's attributes.
						‚è≠ And it is also able to observe layout and perform updates on screen change.
					</aside>
				</section>
				<section data-auto-animate>
					<div class="r-hstack">
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers>
								<script type="text/template">
									/// View that can apply attributes on itself.
									public protocol AttributedView: UIView {
										associatedtype Attributes
									
										/// Starts updating stream of attributes on itself.
										/// - Parameters:
										///   - attributes: The stream of attributes to apply.
										///   - cancellables: Cancellable Set to store updates on.
										func startUpdating(
											attributes: AnyPublisher<Attributes, Never>, 
											store cancellables: inout Set<AnyCancellable>
										)
									}
								</script>
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Of course, if you want your view to be able to update with this property wrapper, 
						you have to make it conform to `AttributedView`.
					</aside>
				</section>
				<section data-auto-animate data-auto-animate-id="view-controller">
					<div class="r-hstack">
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers>
								<script type="text/template">
									final class WWDCBannerViewController: UIViewController {
										var layout: Layout
									
										private var bannerContainer = DSView()
									
										private var backgroundImageView = UIImageView()
									
										private var headerLabel = UILabel()
									
										private var bodyLabel = UILabel()
									
										private var button = UIButton(type: .custom)

										// ...

										override func viewDidLoad() {
											super.viewDidLoad()
											// ...
										}

										// ...
									}
								</script>
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Then having ViewController for our WWDC banner. Ale we need to do
					</aside>
				</section>
				<section data-auto-animate data-auto-animate-id="view-controller">
					<div class="r-hstack">
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="4,7,10,13,16|23-27">
								<script type="text/template">
									final class WWDCBannerViewController: UIViewController {
										var layout: Layout
									
										@LayoutView(attributes: WWDCBannerStyle.container)
										private var bannerContainer = DSView()
									
										@LayoutView(attributes: WWDCBannerStyle.backgroundImage)
										private var backgroundImageView = UIImageView()
									
										@LayoutView(attributes: WWDCBannerStyle.header)
										private var headerLabel = UILabel()
									
										@LayoutView(attributes: WWDCBannerStyle.body)
										private var bodyLabel = UILabel()
									
										@LayoutView(attributes: WWDCBannerStyle.button)
										private var button = UIButton(type: .custom)

										// ...

										override func viewDidLoad() {
											super.viewDidLoad()
											$bannerContainer.startObserving(layout: layout)
											$backgroundImageView.startObserving(layout: layout)
											$headerLabel.startObserving(layout: layout)
											$bodyLabel.startObserving(layout: layout)
											$button.startObserving(layout: layout)
											// ...
										}

										// ...
									}
								</script>
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						... is add property wrappers,

						‚è≠ and start observing layout.

						Well, almost. It's `UIKit` it cannot be to easy.

						Not sure if you remember, but our our banner had different ratio on iPhone and iPads.

						So have to take care about one more thing.
					</aside>
				</section>
				<section>
					<div class="r-hstack">
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="1-17|18-27">
								<script type="text/template">
									/// Adds possibility to update for the Constraint when screen changes.
									public class LayoutConstraint<Constraint, Value> {
										private(set) public var constraint: Constraint
										private(set) public var value: SizeVariants<Value>

										var updateClosure: ((Constraint, Value) -> Void)?

										// ...

										/// Start observing screen and updates itself when screen changes.
										/// - Parameter layout: The layout containing screen.
										func startObserving(layout: Layout) {
											layout.$screen.sink { [unowned self] screen in
												self.updateClosure?(self.constraint, self.value.for(screen: screen))
											}
											.store(in: &cancellables)
										}
									}

									extension Array where Element: LayoutConstraint<NSLayoutConstraint, CGFloat> {
										/// Activates each constrain and start observing layout for screen changes.
										/// - Parameter layout: The layout containing screen.
										public func activateAndObserve(layout: Layout) {
											forEach {
												$0.constraint.isActive = true
												$0.startObserving(layout: layout)
											}
										}
									}
								</script>
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Constrains. 

						I don't want to manually update them for every view or view controller.

						So here is a wrapper on a Constrain that observes changes and update the constrain.

						‚è≠ there is also a method that activate and trigger observing layout for array of constrains.
					</aside>
				</section>
				<section>
					<div class="r-hstack">
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="3-13">
								<script type="text/template">
									override func viewDidLoad() {
										super.viewDidLoad()
										let constrains = [
											LayoutConstraint(
												constraint: bannerContainer.heightAnchor.constraint(
													equalTo: bannerContainer.widthAnchor,
													multiplier: WWDCBannerStyle.bannerRatio.regular
												),
												multiplier: WWDCBannerStyle.bannerRatio
											)
										]

										constrains.activateAndObserve(layout: layout)
										
										// ...
									}
								</script>
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						And using this in code is just a matter of declaring it and activate.
					</aside>
				</section>
				<section>
					<video class="demo-video" data-autoplay src="./assets/uikit-swiftui.mov"></video>
					<aside class="notes" data-markdown>
						Here you can compare the results for SwiftUI and UIKit.
						As you can see, they are identical.
					</aside>
				</section>
<!-- ENDING -->
				<section data-markdown data-auto-animate>
					<script type="text/template">
						# Thank You <!-- .element: class="gradient-text" -->
						Notes:
						Thank you all for being here today.
						
						If you have any questions, now is the time :)
					</script>
				</section>
				<section data-markdown data-auto-animate data-visibility="hidden">
					<script type="text/template">
						# Thank You <!-- .element: class="gradient-text" -->
						<!-- ## Links -->
						<!-- TODO: add links -->
						
						Notes:
						So here is the set of links.
					</script>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				width: 1920,
  				height: 1080,
				// totalTime: 1500,2
				controls: false,
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
