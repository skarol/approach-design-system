<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/skarol.css">
		<link rel="stylesheet" href="styles.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/atom-one-dark.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-timing="20">
					<h2 class="gradient-text">
						<p>Approaching Design System</p>
						<p>in iOS Environment</p>
					</h2>
					<aside class="notes" data-markdown>
						Hello everyone.
						
						Today I will talk about a way of approaching Design System to make this experience as delightfully as possible.
					</aside>
				</section>
				<section class="contact">
					<div class="contact-header">	
						<h3 class="gradient-text">Karolina Samorek</h3>
						<h5>Senior iOS Developer 
							<a href="https://www.lakecoloring.com" target="_blank" rel="noreferrer">
								@lakecoloring
								<img class="app-icon" src="/assets/icons/Icon-1024.png" alt="icon"/>
							</a>
						</h5>
					</div>
					<ul class="contact-links" style="list-style:none">
						<li>
						  <div class="contact-link">
							<a href="https://bit.ly/3dQx4pB" target="_blank" rel="noreferrer">
							  <img class="icon" src="/assets/icons/github.svg" alt="icon"/>@skarol
							</a>
						  </div>
						</li>
						<li>
						  <div class="contact-link">
							<a href="https://bit.ly/3dPg70m" target="_blank" rel="noreferrer">
							  <img class="icon" src="/assets/icons/twitter.svg" alt="icon"/>@skarol_the
							</a>
						  </div>
						</li>
						<!-- <li>
						  <div class="contact-link">
							<a href="mailto:karolina.samorek@gmail.com" target="_blank" rel="noreferrer">
							  <img class="icon" src="/assets/icons/mail.svg" alt="icon"/>
							  karolina.samorek@gmail.com
							</a>
						  </div>
						</li> -->
						<li>
							<div class="contact-link">
							  <a href="https://bit.ly/3dR28Wl" target="_blank" rel="noreferrer">
								<img class="icon" src="/assets/icons/linkedin.svg" alt="icon"/>@karolina.samorek
							  </a>
							</div>
						  </li>
					  </ul>
					<aside class="notes" data-markdown>
						My name is Karolina Samorek
						and I'm a Senior iOS Developer at Lake.

						<!-- At Lake we build user experience with beautiful design. -->
						
						Since I started iOS development, every time I was working on UI, 
						I had mixed feelings.
						
						From one side I really like to work on beautiful things. 
						Being able to interact with something I developed. 
						It just gives me this certain level of satisfaction. 

						However it wasn't always like that. 
						I struggled with creating same things over and over again. 
						With edge cases, like different screen sizes or waiting long to see results due to compilation time.
						It was frustrating experience.

						<!-- And it isn't optimal only for me. Also business suffers, because
						is product is not developed as fast as it could be.
						Not to mention money lost. -->

						So, during this talk I'm will show you what works for me 
						to limit those frustrations
						and embrace building UI.

						‚úã‚úã‚úãüö∞
					</aside>
				</section>
<!-- DEVELOPMENT PERFORMANCE -->
				<section data-markdown>
					<script type="text/template">
						## Shorten the waiting time <!-- .element: class="gradient-text" -->
						* hot reloading
						* Xcode previews
						* modulated codebase
						Note:
						First thing you can do is shorten the time since making a change to seeing the result.
						Ideally, find a way to see results immediately. 
						* you can do it by introducing hot reloading 
						<!-- which Marcin covered in his blogpost: ...  -->
						* or working with multiple Xcode previews. Which is awesome for me, because it let me
						see results on multiple devices at once.
						* You can also modularize codebase and build just a small portion of it every time you change something. 
						
						Those changes might require investing some time up front,
						
						but it pays off very quickly. 

						‚úã‚úã‚úãüö∞
					</script>
				</section>
<!-- EDGE CASES - SIZE VARIANTS -->
				<section data-auto-animate>
					<h2 class="gradient-text">Handle edge cases</h2>
					<img class="iphone-ipad-image" src="/assets/small_large.png" alt="iPhone SE 1st gen vs iPad Pro 12.9 size comparation"/>
					<aside class="notes" data-markdown>
						If it comes to edge cases. 

						Many of them are just related to trying to build UI for variety of screen sizes. 
						
						Sometimes it's just not physically possible to fit same content in all of them.
						Like for example on the smallest iPhone and the biggest iPad.
						<!-- Look how big is the difference. -->
						
						Another times, to look more friendly for the user, the content has to be constructed differently depending on the screen size. 
						
						Each of this exception is basically an if in the code. 
					</aside>
				</section>
				<section data-auto-animate>
					<h2>Handle edge cases</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="|1|3-6|8-12|14-17">
							<script type="text/template">
							let screenInsets = SizeVariants<CGFloat>(small: 12, compact: 16, regular: 24)

							let bannerRatio = SizeVariants<CGFloat>(
								compact: 180.0 / 348.0, 
								regular: 200.0 / 500.0
							)

							let header1 = SizeVariants<DSFont>(
								compact: headers.withSize(32),
								regular: headers.withSize(48)
							)
							private let headers = DSFont.systemFont(ofSize: 22, weight: .bold)

							let image = SizeVariants<DSImage>(
								compact: DSImage(named: "background.compact"),
								regular: DSImage(named: "background.regular")
							)
							</script>
							</code>
					</pre>
					<aside class="notes" data-markdown>
						To simplify things at Lake we created `SizeVariants`. 
						
						You can thing about them as an extended size classes that let you declare rules for each screen size.

						Instead of making exceptions we describe the behavior for each variant.
						
						We use `SizeVariants` to define things such us,
						
						* ‚è≠ insets,
						* ‚è≠ ratio of UI elements, 
						* ‚è≠ fonts 
						* ‚è≠ or even different image assets.
					</aside>
				</section>
				<section data-auto-animate>
					<h2>Handle edge cases</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="3-12|9-10|11-12|7-8|5-6|3-4|26-38">
							<script type="text/template">
							/// Defines a way layout is constructed for different screen sizes.
							public struct SizeVariants<Variant> {
								/// The Variant for iPhones 4".
								public var small: Variant
								/// The Variant for iPhone 4.7".
								public var short: Variant
								/// The Variant for the iPhones wider than iPhone 4.7".
								public var compact: Variant
								/// The Variant for all iPads in portrait orientation.
								public var regular: Variant
								/// The Variant for all iPads in landscape orientation.
								public var wide: Variant

								/// Create SizeVariants.
								/// - Parameters:
								///   - small: The Variant for iPhones 4". 
								///     If not provided `short` is used.
								///   - short: The Variant for iPhone 4.7".
								///     If not provided `compact` is used.
								///   - compact: The Variant for the iPhones wider than iPhone 4.7". 
								///     If not provided `regular` is used.
								///   - regular: The Variant for all iPads in portrait. 
								///     Used as a final fallback for each variant if not provided.
								///   - wide: The Variant for all iPads in landscape. 
								///     If not provided `regular` is used.
								public init(
									small: Variant? = nil, 
									short: Variant? = nil, 
									compact: Variant? = nil, 
									regular: Variant, 
									wide: Variant? = nil
								) {
									self.small = small ?? short ?? compact ?? regular
									self.short = short ?? compact ?? regular
									self.compact = compact ?? regular
									self.regular = regular
									self.wide = wide ?? regular
								}
							}
						</script>
						</code>
					</pre>
					<aside class="notes" data-markdown>
						`SizeVariants` is simple generic struct.
						
						It should define variants in a way that fits to the product you are building.
						
						For example, Lake is iPad-first app
						
						‚è≠ and we use regular as default variant. It handles all iPads in portrait orientation (excluding split view ofc).
						
						‚è≠ In our case it's common that iPads in landscape orientation have it's dedicated layout,
						so we have a variant called wide.
						
						‚è≠ Compact is basically iPhone in Portrait (as we don't support landscape for iPhone in our app).
						To support edge cases for smaller iPhones we introduced
						
						‚è≠ short which handles iPhones with screen smaller than 4.7 inches.

						‚è≠ And small for the smallest iPhones with 4 inches screen size.
						
						‚è≠ You can see that variant, if not defined, fallbacks to larger one.
						
						And at the end to regular, which has to be always provided.

						‚úã‚úã‚úãüö∞
					</aside>
				</section>
<!-- DEFINING DESIGN SYSTEM -->
				<section data-auto-animate data-markdown>
					<script type="text/template">
						### Eliminate repetitive work <!-- .element: class="gradient-text" -->
						
						Notes:
						The best way I know to eliminate repetitive UI work
					</script>
				</section>
				<section data-auto-animate data-markdown>
					<script type="text/template">
						### Eliminate repetitive work <!-- .element: class="gradient-text" -->
						#### by
						#### adopting
						
						Notes:
						is to adopt
					</script>
				</section>
				<section data-auto-animate data-markdown>
					<script type="text/template">
						### Eliminate repetitive work <!-- .element: class="gradient-text" -->
						#### by
						#### adopting
						## The Design System <!-- .element: class="gradient-text" -->
						
						Notes:
						the Design System.
						
						Simply create a framework that will let you build UI from reusable components
						
						just like playing LEGO bricks.

						‚úã
					</script>
				</section>
				<section data-auto-animate data-markdown>
					<script type="text/template">
						## The Design System <!-- .element: class="gradient-text" -->
						
						Notes:
						There are many ways to create a Design System, 

						however there is one significant thing I've learned over the years.
						
						The Design System, is a product itself, just like apps we work on.

						And this product should be designed
						
						having best interest of it's users
						
						in mind.
					</script>
				</section>
				<section data-auto-animate data-markdown>
					<script type="text/template">
						## The Design System <!-- .element: class="gradient-text" -->
						<!-- TODO: ADD GRAPHIC -->
						* Designers
						* UX Researchers
						* Product Owners
						* Developers
						Notes:
						And by Users I mean 
						* Designers
						* UX Researchers
						* Product Owners
						* and us, Developers

						To get maximum out of The Design System
						each of those groups has to be involved in the process of creating it.

						‚úã‚úã‚úã
					</script>
				</section>
				<section>
					<h2>Tokens</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="2-13|16-20, 24-25, 27-28">
							/// All DesignSystem Tokens namespace.
							public enum DSTokens {
								/// All DesignSystem Fonts namespace.
								public enum Fonts {}
								/// All DesignSystem Colors namespace.
								public enum Colors {}
								/// All DesignSystem Icons namespace.
								public enum Icons {}
								/// All DesignSystem Spaces namespace.
								public enum Spaces {}
								
								// ..
							}

							extension DSTokens.Colors {
								/// Background/Primary color
								public static let backgroundPrimary = DSColor(
									light: CGColor.from(hex: "#F5F5F5")!,
									dark: CGColor.from(hex: "#222222")!
								)
								
								// ...
								
								/// Text/OnColor color
								public static let textOnColor = DSColor(CGColor.from(hex: "#FAFAFA")!)

								/// Accent/Primary/Default
								public static let accentPrimaryDefault = DSColor(CGColor.from(hex: "#AA49DB")!)
								
								// ...
							}

						</code>
					</pre>
					
					<aside class="notes" data-markdown>
						You can start from defining tokens, which are parameters you can use to describe components.
						
						Like Fonts, Colors, Icons, Spaces etc.

						<!-- POZMIENIAC -->
						If you already support `UIKit` and `SwiftUI`, or you are thinking about transitioning into `SwiftUI`
						define your tokens in a way you will be able to use them with both frameworks.

						You might use `UIKit` types and convert them to `SwiftUI` ones, or the opposite. 
						You could also create your own types.
						
						‚è≠ Like here, where we have our own type `Design System Color` which uses `CGColor` from `CoreGraphics` library.
						So this type is independent from `UIKit`, but can be easily used with it
						as well as with `SwiftUI`.
						
						‚úã
					</aside>
				</section>
				<section>
					<h2>Control states</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="|5-7|8-10|11-13">
							/// State of UI control.
							///
							/// Possible options: ``normal``, ``highlighted`` and ``disabled``.
							public struct ControlState: OptionSet, Hashable {
								/// Normal UI control's state.
								/// Applicable when no user action is being performed and control is enabled.
								public static let normal = ControlState(rawValue: 1)
								/// Highlighted UI control's state.
								/// Applicable when user taps/presses and control is enabled.
								public static let highlighted = ControlState(rawValue: 2)
								/// Disabled UI control's state.
								/// Applicable when control isn't enabled.
								public static let disabled = ControlState(rawValue: 4)

								// ...
							}
						</code>
					</pre>
					<aside class="notes" data-markdown>
						Then think about all possible states you want your controls to have.

						* ‚è≠ For example the normal state, when no user action is being performed.
						* ‚è≠ highlighted, when user taps or press the control
						* ‚è≠ and disabled, when no user interaction is possible.

						‚úã
					</aside>
				</section>
				<section data-markdown data-auto-animate>
					<script type="text/template">
						## Style Components <!-- .element: class="gradient-text" -->

						Note:
						By combining `Tokens`, `ControlStates` and `SizeVariants` together 
						
						you can define styles of your components. 
					</script>
				</section>
				<section data-auto-animate>
					<h2>Style Components</h2>
					<div style="margin-left: 1rem;">
						<img src="./assets/button-animation.gif" />
					</div>
					<aside class="notes" data-markdown>
						Let's follow an example of styling Call To Action Button like this one.
					</aside>
				</section>
				<section data-auto-animate>
					<h2>Style Components</h2>
					<div style="margin-left: 1rem;">
						<img src="./assets/button-animation.gif" />
					</div>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="2-3|7-8|14-25|26-35">
							<script type="text/template">
							extension DSTokens.Fonts {	
								static let button = SizeVariants<DSFont>(regular: buttons)
								private static let buttons = DSFont.systemFont(ofSize: 17, weight: .medium)
							}

							extension DSStyles.Texts {
								public static let button = DSTokens.Fonts.button
									.toTextAttributes(color: DSTokens.Colors.textOnColor)
							}

							extension DSStyles.Buttons {
								public static let ctaPrimary = DSStyles.Texts.button
									.toButtonAttributes(
										stateViewAttributes: SizeVariants(
											regular: [
												.normal: .init(
													backgroundColor: DSTokens.Colors.accentPrimaryDefault,
													cornerRadius: DSTokens.CornerRadiuses.l
												),
												.highlighted: .init(
													backgroundColor: DSTokens.Colors.accentPrimaryHighlighted,
													cornerRadius: DSTokens.CornerRadiuses.s
												)
											]
										),
										contentInsets: SizeVariants<LayoutEdgeInsets>(
											compact: [
												.horizontal: DSTokens.Spaces.s, 
												.vertical: DSTokens.Spaces.xs
											],
											regular: [
												.horizontal: DSTokens.Spaces.m, 
												.vertical: DSTokens.Spaces.s
											]
										)
									)
							}
						</script>
						</code>
					</pre>
					<aside class="notes" data-markdown>
						* first we define font for a button
						* ‚è≠ later we use it to create a text style, with specific text color
						* ‚è≠ and then we apply attributes for control states, such us background color and corner radius
						* ‚è≠ and at the end, we provide different content insets.

						‚úã
					</aside>
				</section>
<!-- Attributes -->
				<section>
					<h2>Components Attributes</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers>
							/// UI Attributes that can be applied on a view to change it visually.
							public struct ViewAttributes: Equatable, Hashable {
								/// View's Background Color. Wont't be set if ``nil``.
								public var backgroundColor: DSColor?
								/// View's Tint Color. Wont't be set if ``nil``.
								public var tintColor: DSColor?
								/// Attributes applied to view's border. Wont't be set if ``nil``.
								public var borderAttributes: BorderAttributes?
								/// View's corner radius. Wont't be set if ``nil``.
								public var cornerRadius: CGFloat?
								/// Attributes related to view's shadow. Wont't be set if ``nil``.
								public var shadowAttributes: ShadowAttributes?

								// ...
							}
						</code>
					</pre>
					<aside class="notes" data-markdown>
						For better understanding, let's take a look on attributes that define style of a component.
						This is just an example of possible parameters for a view component. 
						The properties that describe a component can be different depending on your Design System.
					</aside>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Applying attributes to a Button
						```swift []
						/// Design System Button Style.
						///
						/// Applies ``ButtonAttributes`` to a button.
						public struct DSButtonStyle: ButtonStyle {
							public let attributes: ButtonAttributes

							public init(attributes: ButtonAttributes) {
								self.attributes = attributes
							}

							/// Creates a view that represents the body of a button.
							///
							/// The system calls this method for each ```Button``` instance in a view
							/// hierarchy where this style is the current button style.
							///
							/// - Parameter configuration : The properties of the button.
							public func makeBody(configuration: Configuration) -> some View {
								let currentState: ControlState = configuration.isPressed ? .highlighted : .normal
								let currentStateAttributes = attributes.stateAttributes[currentState] ?? attributes.stateAttributes[.normal]
								configuration.label
									.apply(textAttributes: currentStateAttributes?.textAttributes)
									.padding(attributes.contentInsets)
									.apply(viewAttributes: currentStateAttributes?.viewAttributes)
									.animation(.default, value: configuration.isPressed)
							}
						}
						```
						Note:
						To apply attributes to a component create set of methods and types.
						
						Like for `Button` in `SwiftUI` where you can implement a struct conforming a `ButtonStyle`. 
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Applying attributes to a Text
						```swift []
						/// Applies ``TextAttributes`` for given view.
						///
						/// - Parameters:
						///   - attributes: The ``TextAttributes`` to apply.
						/// - Returns: Modified View.
						@ViewBuilder func apply(textAttributes: TextAttributes) -> some View {
							self.if(textAttributes.lineSpacing) { view, lineSpacing in
								view.lineSpacing(lineSpacing)
							}
							.font(Font(textAttributes.font))
							.foregroundColor(Color(dsColor: textAttributes.color))
							.if(textAttributes.alignment) { view, alignment in
								view.multilineTextAlignment(alignment)
							}
						}
						```
						Note:
						Because there is no such thing like `TextStyle` in `SwiftUI` ,
						`TextAttributes` are applied by a function.

						‚úã
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Applying attributes to a View
						```swift []
						/// Applies View Attributes for given view.
						/// - Parameter attributes: The View Attributes to apply on a view.
						public func apply(attributes: ViewAttributes) {
							if let backgroundColor = attributes.backgroundColor {
								self.backgroundColor = UIColor(dsColor: backgroundColor)
							}
							if let tintColor = attributes.tintColor {
								self.tintColor = UIColor(dsColor: tintColor)
							}
							layer.cornerRadius = attributes.cornerRadius ?? .zero
							if let shadowAttributes = attributes.shadowAttributes {
								apply(attributes: shadowAttributes)
							}
							if let borderAttributes = attributes.borderAttributes {
								apply(attributes: borderAttributes)
							}
						}
						```
						Note:
						In `UIKit` we can use same attributes, however we have to write separate functions applying styles.

						‚úã

						There are many more helpers like the ones I've shown.
						
						The thing is, you create them once and use them later on, so there is no sense for me 
						to go though them on this talk.
						
						If you are interested there is an repository on my github, where you can get more details.
						I'll link to it at the end of my presentation.

						‚úã‚úã‚úãüö∞
					</script>
				</section>
<!-- DEMO -->				
				<section data-auto-animate>
					<h2 class="gradient-text">Feature level of Styles</h2>
					<aside class="notes" data-markdown>
						Before I've shown styling a Call To Action Button.
						The style was defined on the Design System level.
						
						However, we can also take advantage of them on a feature level.

						Imagine we have to create a banner for WWDC Community Event.
					</aside>
				</section>
				<section data-auto-animate>
					<h2 class="gradient-text">Feature level of Styles</h2>
					<img src="./assets/wwdc_banner_design.png" alt="example design" />
					<aside class="notes" data-markdown>
						It should look like this.
						
						Nothing super fancy, but it's slightly different on each device.
						
						‚úã‚úã‚úãüö∞
					</aside>
				</section>
				<section data-auto-animate>
					<h2>Feature level of Styles</h2>
					<pre>
						<code class="language-swift hljs" data-trim data-noescape data-line-numbers="|2-3">
							<script type="text/template">
							enum WWDCBannerStyle {
								static let container = DSStyles.Shadows.banner
									.toViewAttributes(cornerRadius: DSTokens.CornerRadiuses.l)
							
								static let header = DSStyles.Texts.header2onColor
								static let body = DSStyles.Texts.bodyOnColor
								static let button = DSStyles.Buttons.primaryCTA

								static let bannerRatio = SizeVariants<CGFloat>(
									compact: 230.0 / 348.0, 
									regular: 200.0 / 500.0
								)
								static let backgroundImage = DSStyles.Shadows.banner
									.toViewAttributes(cornerRadius: DSTokens.CornerRadiuses.l)
									.toImageAttributes(image: .init(
										compact: DSImage(named: "background.compact"),
										regular: DSImage(named: "background.regular")
									))
							}
							</script>
						</code>
					</pre>
					<aside class="notes" data-markdown>
						We can start from defining feature styles, by reusing the Design System.
						
						‚è≠ Like taking already defined shadow and converting it to `ViewAttributes` with specific corner radius.

						<!-- Those styles can be used lated on with `UIKit` or `SwiftUI`. -->
					</aside>
				</section>
				<section data-auto-animate>
					<h2>SwiftUI</h2>
					<div class="r-hstack">
						<img src="./assets/swiftUI/01.png" />
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="4-16|6-9">
								struct WWDCBannerView: View {
									@EnvironmentObject var layout: Layout
								
									var body: some View {
										Image(
											SizeVariants(
												compact: "background.compact",
												regular: "background.regular"
											).for(screen: layout.screen)
										)
										.resizable()
										.aspectRatio(contentMode: .fit)
										.frame(maxWidth: 500)
										.padding(DSTokens.Spaces.l)
									}
								}
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Having styles defined we can start building UI. Here we have just a background of the banner.

						‚è≠  We already provide asset as a `SizeVariant`.
						
						We could take advantage of Xcode assets and instead of universal define iPhone and iPad separately.
						However split view would then look really bad.
					</aside>
				</section>
				<section data-auto-animate>
					<h2>SwiftUI</h2>
					<div class="r-hstack">
						<img src="./assets/swiftUI/02.png" />
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="12-14">
								struct WWDCBannerView: View {
									@EnvironmentObject var layout: Layout
								
									var body: some View {
										Image(
											SizeVariants(
												compact: "background.compact",
												regular: "background.regular"
											).for(screen: layout.screen)
										)
										.resizable()
										.apply(viewAttributes: WWDCBannerStyle.container.for(
											screen: layout.screen
										))
										.aspectRatio(contentMode: .fit)
										.frame(maxWidth: 500)
										.padding(DSTokens.Spaces.l)
									}
								}
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Buy simply adding one function call we restyle the background, to have rounded corners and shadow below.
					</aside>
				</section>
				<section data-auto-animate>
					<h2>SwiftUI</h2>
					<div class="r-hstack">
						<img src="./assets/swiftUI/02.png" />
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="20-31">
								struct WWDCBannerView: View {
									@EnvironmentObject var layout: Layout
								
									var body: some View {
										Image(
											SizeVariants(
												compact: "background.compact",
												regular: "background.regular"
											).for(screen: layout.screen)
										)
										.resizable()
										.apply(viewAttributes: WWDCBannerStyle.container.for(
											screen: layout.screen
										))
										.aspectRatio(contentMode: .fit)
										.frame(maxWidth: 500)
										.padding(DSTokens.Spaces.l)
									}

									@ViewBuilder private var foreground: some View {
										HStack {
											Spacer()
											VStack(alignment: .trailing, spacing: DSTokens.Spaces.s) {
												Text("WWDC22")
												Text("Community Event")
												Spacer()
												Button("Join Now") { /* ... */ }
											}
											.padding(DSTokens.Spaces.l)
										}
									}
								}
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Now let see what we can do with the foreground. 
						
						Simple `VStack` with `Texts`, `Button` and `Spacer` in between should work.

						Let's add it to our banner as an overlay.
					</aside>
				</section>
				<section data-auto-animate>
					<h2>SwiftUI</h2>
					<div class="r-hstack">
						<img src="./assets/swiftUI/03.png" />
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="16|21-32">
								struct WWDCBannerView: View {
									@EnvironmentObject var layout: Layout
								
									var body: some View {
										Image(
											SizeVariants(
												compact: "background.compact",
												regular: "background.regular"
											).for(screen: layout.screen)
										)
										.resizable()
										.apply(viewAttributes: WWDCBannerStyle.container.for(
											screen: layout.screen
										))
										.aspectRatio(contentMode: .fit)
										.overlay(foreground)
										.frame(maxWidth: 500)
										.padding(DSTokens.Spaces.l)
									}

									@ViewBuilder private var foreground: some View {
										HStack {
											Spacer()
											VStack(alignment: .trailing, spacing: DSTokens.Spaces.s) {
												Text("WWDC22")
												Text("Community Event")
												Spacer()
												Button("Join Now") { /* ... */ }
											}
											.padding(DSTokens.Spaces.l)
										}
									}
								}
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Not bad. 
						
						However it doesn't look like on the design.

						‚è≠ Let's style new components.
					</aside>
				</section>
				<section data-auto-animate>
					<h2>SwiftUI</h2>
					<div class="r-hstack">
						<img src="./assets/swiftUI/04.png" />
						<pre data-id="code-animation">
							<code class="language-swift hljs" data-trim data-noescape data-line-numbers="26-28,30-32,35-37">
								struct WWDCBannerView: View {
									@EnvironmentObject var layout: Layout
								
									var body: some View {
										Image(
											SizeVariants(
												compact: "background.compact",
												regular: "background.regular"
											).for(screen: layout.screen)
										)
										.resizable()
										.apply(viewAttributes: WWDCBannerStyle.container.for(
											screen: layout.screen
										))
										.aspectRatio(contentMode: .fit)
										.overlay(foreground)
										.frame(maxWidth: 500)
										.padding(DSTokens.Spaces.l)
									}

									@ViewBuilder private var foreground: some View {
										HStack {
											Spacer()
											VStack(alignment: .trailing, spacing: DSTokens.Spaces.s) {
												Text("WWDC22")
													.apply(textAttributes: WWDCBannerStyle.header.for(
														screen: layout.screen
													))
												Text("Community Event")
													.apply(textAttributes: WWDCBannerStyle.body.for(
														screen: layout.screen
													))
												Spacer()
												Button("Join Now") { /* ... */ }
													.buttonStyle(DSButtonStyle(
														attributes: WWDCBannerStyle.button.for(screen: layout.screen)
													))
											}
											.padding(DSTokens.Spaces.l)
										}
									}
								}
							</code>
						</pre>
					</div>
					<aside class="notes" data-markdown>
						Agin, few lines of code and UI is transformed.

						The best thing is that it does all the magic for edge cases.
					</aside>
				</section>
				<section data-auto-animate>
					<h2>SwiftUI</h2>
					<video class="demo-video" data-autoplay src="./assets/swiftUI/final.mov"></video>
					<aside class="notes" data-markdown>
						It looks good in
						* portrait
						* landscape
						* and even in split view.

						You can se that it
					</aside>
				</section>

<!-- ENDING -->
				<section data-markdown>
					<script type="text/template">
						# Thank You <!-- .element: class="gradient-text" -->
					</script>
					<aside class="notes" data-markdown>
						Thank you all for being here today.

						If you have any questions, now is the time :)
					</aside>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Links <!-- .element: class="gradient-text" -->
						<!-- TODO: add links -->
					</script>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				width: 1920,
  				height: 1080,
				totalTime: 1800,
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
